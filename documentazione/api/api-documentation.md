# API Documentation - Sistema di Crafting\n\n## Funzioni Principali\n\n### craftingUtils.ts\n\n#### `validateCraftingAttempt(recipe, inventory, characterSheet, knownRecipeIds)`\n\n**Descrizione**: Valida se un tentativo di crafting è possibile\n\n**Parametri**:\n- `recipe: Recipe` - La ricetta da validare\n- `inventory: InventoryItem[]` - L'inventario del giocatore\n- `characterSheet: CharacterSheet` - Il character sheet del giocatore\n- `knownRecipeIds: string[]` - Array degli ID delle ricette conosciute\n\n**Ritorna**: `string | null` - Stringa con errore se validazione fallisce, null se successo\n\n**Esempio**:\n```typescript\nconst error = validateCraftingAttempt(recipe, inventory, character, knownRecipes);\nif (error) {\n  console.log(`Crafting failed: ${error}`);\n} else {\n  // Procedi con il crafting\n}\n```\n\n#### `calculateCraftingXP(recipe, character)`\n\n**Descrizione**: Calcola l'esperienza guadagnata dal crafting\n\n**Parametri**:\n- `recipe: Recipe` - La ricetta craftata\n- `character: CharacterSheet` - Il character sheet del giocatore\n\n**Ritorna**: `number` - Punti esperienza guadagnati\n\n**Esempio**:\n```typescript\nconst xp = calculateCraftingXP(recipe, character);\ngameStore.addExperience(xp);\n```\n\n#### `getMaterialStatus(recipe, inventory, itemDatabase)`\n\n**Descrizione**: Ottiene lo stato dei materiali per una ricetta\n\n**Parametri**:\n- `recipe: Recipe` - La ricetta da controllare\n- `inventory: InventoryItem[]` - L'inventario del giocatore\n- `itemDatabase: Record<string, any>` - Database degli oggetti\n\n**Ritorna**: `MaterialStatus[]` - Array con stato di ogni materiale\n\n**Esempio**:\n```typescript\nconst status = getMaterialStatus(recipe, inventory, items);\nstatus.forEach(material => {\n  console.log(`${material.itemName}: ${material.owned}/${material.required}`);\n});\n```\n\n#### `canCraftRecipe(recipe, inventory, character)`\n\n**Descrizione**: Verifica se una ricetta può essere craftata\n\n**Parametri**:\n- `recipe: Recipe` - La ricetta da verificare\n- `inventory: InventoryItem[]` - L'inventario del giocatore\n- `character: CharacterSheet` - Il character sheet del giocatore\n\n**Ritorna**: `boolean` - True se craftabile, false altrimenti\n\n**Esempio**:\n```typescript\nif (canCraftRecipe(recipe, inventory, character)) {\n  // Mostra pulsante craft abilitato\n} else {\n  // Mostra pulsante craft disabilitato\n}\n```\n\n### craftingTypes.ts\n\n#### `processCraftingByType(recipe, inventory, character, itemDatabase)`\n\n**Descrizione**: Dispatcher principale per gestire tutti i tipi di crafting\n\n**Parametri**:\n- `recipe: Recipe` - La ricetta da processare\n- `inventory: InventoryItem[]` - L'inventario del giocatore\n- `character: CharacterSheet` - Il character sheet del giocatore\n- `itemDatabase: Record<string, ItemData>` - Database degli oggetti\n\n**Ritorna**: `CraftingResult` - Risultato dell'operazione di crafting\n\n**Esempio**:\n```typescript\nconst result = processCraftingByType(recipe, inventory, character, items);\nif (result.success) {\n  console.log(result.message);\n  // Applica modifiche inventario\n  result.itemsRemoved?.forEach(item => removeItem(item.itemId, item.quantity));\n  result.itemsAdded?.forEach(item => addItem(item.itemId, item.quantity));\n} else {\n  console.error(result.message);\n}\n```\n\n#### `validateRecipeForType(recipe, itemDatabase)`\n\n**Descrizione**: Valida una ricetta per un tipo specifico\n\n**Parametri**:\n- `recipe: Recipe` - La ricetta da validare\n- `itemDatabase: Record<string, ItemData>` - Database degli oggetti\n\n**Ritorna**: `{ valid: boolean; errors: string[] }` - Risultato validazione\n\n**Esempio**:\n```typescript\nconst validation = validateRecipeForType(recipe, itemDatabase);\nif (!validation.valid) {\n  console.error('Recipe validation errors:', validation.errors);\n}\n```\n\n### recipeLoader.ts\n\n#### `loadRecipes()`\n\n**Descrizione**: Carica le ricette dal file JSON\n\n**Parametri**: Nessuno\n\n**Ritorna**: `Promise<RecipeLoadResult>` - Risultato del caricamento\n\n**Esempio**:\n```typescript\nconst result = await loadRecipes();\nif (result.success) {\n  console.log(`Loaded ${result.recipes.length} recipes`);\n  setRecipes(result.recipes);\n} else {\n  console.error('Failed to load recipes:', result.errors);\n}\n```\n\n#### `filterRecipesByAvailability(recipes, inventory, availableOnly)`\n\n**Descrizione**: Filtra ricette per disponibilità materiali\n\n**Parametri**:\n- `recipes: Recipe[]` - Array di ricette da filtrare\n- `inventory: InventoryItem[]` - Inventario del giocatore\n- `availableOnly: boolean` - Se true, restituisce solo craftabili\n\n**Ritorna**: `Recipe[]` - Ricette filtrate\n\n**Esempio**:\n```typescript\nconst craftableRecipes = filterRecipesByAvailability(allRecipes, inventory, true);\nconst uncraftableRecipes = filterRecipesByAvailability(allRecipes, inventory, false);\n```\n\n#### `searchRecipes(recipes, query, itemDatabase)`\n\n**Descrizione**: Cerca ricette per nome o descrizione\n\n**Parametri**:\n- `recipes: Recipe[]` - Array di ricette da cercare\n- `query: string` - Termine di ricerca\n- `itemDatabase: Record<string, any>` - Database degli oggetti\n\n**Ritorna**: `Recipe[]` - Ricette che corrispondono alla ricerca\n\n**Esempio**:\n```typescript\nconst searchResults = searchRecipes(allRecipes, 'coltello', itemDatabase);\nconsole.log(`Found ${searchResults.length} recipes matching 'coltello'`);\n```\n\n### craftingOptimizations.ts\n\n#### `useMemoizedAvailableRecipes(allRecipes, knownRecipeIds)`\n\n**Descrizione**: Hook per memoizzare le ricette disponibili\n\n**Parametri**:\n- `allRecipes: Recipe[]` - Tutte le ricette caricate\n- `knownRecipeIds: string[]` - ID delle ricette conosciute\n\n**Ritorna**: `Recipe[]` - Ricette disponibili memoizzate\n\n**Esempio**:\n```typescript\nconst availableRecipes = useMemoizedAvailableRecipes(allRecipes, knownRecipeIds);\n// Le ricette vengono ricalcolate solo quando cambiano le dipendenze\n```\n\n#### `useMemoizedMaterialStatus(recipe, inventory, itemDatabase)`\n\n**Descrizione**: Hook per memoizzare lo stato dei materiali\n\n**Parametri**:\n- `recipe: Recipe | null` - Ricetta selezionata\n- `inventory: InventoryItem[]` - Inventario del giocatore\n- `itemDatabase: Record<string, any>` - Database degli oggetti\n\n**Ritorna**: `MaterialStatus[]` - Stato materiali memoizzato\n\n**Esempio**:\n```typescript\nconst materialStatus = useMemoizedMaterialStatus(selectedRecipe, inventory, items);\n// Lo stato viene ricalcolato solo quando cambiano recipe, inventory o items\n```\n\n#### `clearAllCaches()`\n\n**Descrizione**: Forza la pulizia di tutte le cache\n\n**Parametri**: Nessuno\n\n**Ritorna**: `void`\n\n**Esempio**:\n```typescript\n// Pulisci cache quando necessario (es. cambio personaggio)\nclearAllCaches();\n```\n\n#### `getCacheStats()`\n\n**Descrizione**: Ottiene statistiche delle cache\n\n**Parametri**: Nessuno\n\n**Ritorna**: `{ recipe: CacheStats; material: CacheStats; craftability: CacheStats }`\n\n**Esempio**:\n```typescript\nconst stats = getCacheStats();\nconsole.log(`Recipe cache: ${stats.recipe.size} entries, ${stats.recipe.hitRate}% hit rate`);\n```\n\n## Store API (craftingStore.ts)\n\n### Stato\n\n```typescript\ninterface CraftingState {\n  // UI State\n  selectedRecipeIndex: number;    // Indice ricetta selezionata\n  isOpen: boolean;                // Se schermata crafting è aperta\n  \n  // Data State\n  allRecipes: Recipe[];           // Tutte le ricette caricate\n  knownRecipeIds: string[];       // ID ricette conosciute dal giocatore\n}\n```\n\n### Azioni\n\n#### `setSelectedRecipe(index: number)`\n\n**Descrizione**: Imposta la ricetta selezionata\n\n**Esempio**:\n```typescript\nconst { setSelectedRecipe } = useCraftingStore();\nsetSelectedRecipe(2); // Seleziona la terza ricetta\n```\n\n#### `openCrafting()`\n\n**Descrizione**: Apre la schermata di crafting\n\n**Esempio**:\n```typescript\nconst { openCrafting } = useCraftingStore();\nopenCrafting();\n```\n\n#### `closeCrafting()`\n\n**Descrizione**: Chiude la schermata di crafting\n\n**Esempio**:\n```typescript\nconst { closeCrafting } = useCraftingStore();\ncloseCrafting();\n```\n\n#### `craftItem(recipeId: string): Promise<boolean>`\n\n**Descrizione**: Tenta di creare un oggetto\n\n**Parametri**:\n- `recipeId: string` - ID della ricetta da craftare\n\n**Ritorna**: `Promise<boolean>` - True se successo, false se fallimento\n\n**Esempio**:\n```typescript\nconst { craftItem } = useCraftingStore();\nconst success = await craftItem('sharpened_knife');\nif (success) {\n  console.log('Crafting successful!');\n} else {\n  console.log('Crafting failed!');\n}\n```\n\n#### `initializeRecipes(): Promise<void>`\n\n**Descrizione**: Inizializza il sistema di crafting caricando le ricette\n\n**Esempio**:\n```typescript\nconst { initializeRecipes } = useCraftingStore();\nawait initializeRecipes();\n```\n\n#### `unlockRecipeById(recipeId: string): boolean`\n\n**Descrizione**: Sblocca una ricetta per ID\n\n**Parametri**:\n- `recipeId: string` - ID della ricetta da sbloccare\n\n**Ritorna**: `boolean` - True se sbloccata, false se già conosciuta\n\n**Esempio**:\n```typescript\nconst { unlockRecipeById } = useCraftingStore();\nconst unlocked = unlockRecipeById('healing_potion');\nif (unlocked) {\n  console.log('New recipe unlocked!');\n}\n```\n\n#### `unlockRecipesByLevel(level: number): string[]`\n\n**Descrizione**: Sblocca ricette basate sul livello del personaggio\n\n**Parametri**:\n- `level: number` - Livello attuale del personaggio\n\n**Ritorna**: `string[]` - Array degli ID delle ricette sbloccate\n\n**Esempio**:\n```typescript\nconst { unlockRecipesByLevel } = useCraftingStore();\nconst newRecipes = unlockRecipesByLevel(5);\nnewRecipes.forEach(recipeId => {\n  console.log(`Unlocked recipe: ${recipeId}`);\n});\n```\n\n### Selettori\n\n#### `getAvailableRecipes(): Recipe[]`\n\n**Descrizione**: Ottiene le ricette disponibili (conosciute dal giocatore)\n\n**Esempio**:\n```typescript\nconst { getAvailableRecipes } = useCraftingStore();\nconst available = getAvailableRecipes();\nconsole.log(`Player knows ${available.length} recipes`);\n```\n\n#### `canCraftRecipe(recipeId: string): boolean`\n\n**Descrizione**: Verifica se una ricetta può essere craftata\n\n**Parametri**:\n- `recipeId: string` - ID della ricetta da verificare\n\n**Ritorna**: `boolean` - True se craftabile\n\n**Esempio**:\n```typescript\nconst { canCraftRecipe } = useCraftingStore();\nif (canCraftRecipe('sharpened_knife')) {\n  // Abilita pulsante craft\n}\n```\n\n#### `getMaterialStatus(recipeId: string): MaterialStatus[]`\n\n**Descrizione**: Ottiene lo stato dei materiali per una ricetta\n\n**Parametri**:\n- `recipeId: string` - ID della ricetta\n\n**Ritorna**: `MaterialStatus[]` - Stato di ogni materiale richiesto\n\n**Esempio**:\n```typescript\nconst { getMaterialStatus } = useCraftingStore();\nconst status = getMaterialStatus('sharpened_knife');\nstatus.forEach(material => {\n  const color = material.sufficient ? 'green' : 'red';\n  console.log(`${material.itemName}: ${material.owned}/${material.required} (${color})`);\n});\n```\n\n#### `getSelectedRecipe(): Recipe | null`\n\n**Descrizione**: Ottiene la ricetta attualmente selezionata\n\n**Esempio**:\n```typescript\nconst { getSelectedRecipe } = useCraftingStore();\nconst selected = getSelectedRecipe();\nif (selected) {\n  console.log(`Selected recipe: ${selected.id}`);\n}\n```\n\n#### `getCraftingStats()`\n\n**Descrizione**: Ottiene statistiche del crafting\n\n**Ritorna**: Oggetto con statistiche complete\n\n**Esempio**:\n```typescript\nconst { getCraftingStats } = useCraftingStore();\nconst stats = getCraftingStats();\nconsole.log(`Progress: ${stats.completionPercentage}% (${stats.knownRecipes}/${stats.totalRecipes})`);\n```\n\n## Tipi TypeScript\n\n### Recipe\n\n```typescript\ninterface Recipe {\n  id: string;                    // Identificatore unico\n  type?: RecipeType;             // Tipo di crafting\n  resultItemId: string;          // ID oggetto risultante\n  resultQuantity: number;        // Quantità prodotta\n  components: RecipeComponent[]; // Materiali richiesti\n  skillRequirement?: SkillRequirement; // Requisito abilità\n  unlockedByLevel?: number;      // Livello sblocco automatico\n  unlockedByManual?: string;     // ID manuale per sblocco\n  category?: string;             // Categoria per organizzazione\n  description?: string;          // Descrizione ricetta\n  upgradeConfig?: UpgradeConfig; // Config per miglioramenti\n  repairConfig?: RepairConfig;   // Config per riparazioni\n}\n```\n\n### RecipeComponent\n\n```typescript\ninterface RecipeComponent {\n  itemId: string;    // ID del materiale\n  quantity: number;  // Quantità richiesta\n}\n```\n\n### MaterialStatus\n\n```typescript\ninterface MaterialStatus {\n  itemId: string;     // ID del materiale\n  itemName: string;   // Nome del materiale\n  owned: number;      // Quantità posseduta\n  required: number;   // Quantità richiesta\n  sufficient: boolean; // Se quantità è sufficiente\n}\n```\n\n### CraftingResult\n\n```typescript\ninterface CraftingResult {\n  success: boolean;   // Se operazione è riuscita\n  message: string;    // Messaggio per l'utente\n  itemsAdded?: Array<{ itemId: string; quantity: number }>;\n  itemsRemoved?: Array<{ itemId: string; quantity: number }>;\n  xpGained?: number;  // Esperienza guadagnata\n}\n```\n\n## Esempi di Utilizzo\n\n### Implementare Nuova Tipologia di Crafting\n\n```typescript\n// 1. Estendere il tipo\nexport type RecipeType = 'creation' | 'upgrade' | 'repair' | 'dismantle' | 'enhancement' | 'fusion';\n\n// 2. Implementare handler\nconst handleFusionCrafting = (\n  recipe: Recipe,\n  inventory: InventoryItem[],\n  character: CharacterSheet,\n  itemDatabase: Record<string, ItemData>\n): CraftingResult => {\n  // Logica specifica per fusion\n  return {\n    success: true,\n    message: 'Fusion completed!',\n    itemsAdded: [{ itemId: recipe.resultItemId, quantity: 1 }],\n    itemsRemoved: recipe.components,\n    xpGained: 30\n  };\n};\n\n// 3. Aggiungere al dispatcher\nswitch (recipeType) {\n  case 'fusion':\n    return handleFusionCrafting(recipe, inventory, character, itemDatabase);\n  // ...\n}\n```\n\n### Creare Componente Crafting Personalizzato\n\n```typescript\nconst CustomCraftingPanel: React.FC = () => {\n  const {\n    getAvailableRecipes,\n    canCraftRecipe,\n    getMaterialStatus,\n    craftItem,\n    setSelectedRecipe\n  } = useCraftingStore();\n  \n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const recipes = getAvailableRecipes();\n  const selectedRecipe = recipes[selectedIndex];\n  \n  const handleCraft = async () => {\n    if (selectedRecipe && canCraftRecipe(selectedRecipe.id)) {\n      const success = await craftItem(selectedRecipe.id);\n      if (success) {\n        // Mostra successo\n      } else {\n        // Mostra errore\n      }\n    }\n  };\n  \n  return (\n    <div>\n      {recipes.map((recipe, index) => (\n        <div \n          key={recipe.id}\n          onClick={() => setSelectedIndex(index)}\n          className={index === selectedIndex ? 'selected' : ''}\n        >\n          {recipe.description}\n          {canCraftRecipe(recipe.id) ? '✓' : '✗'}\n        </div>\n      ))}\n      \n      {selectedRecipe && (\n        <div>\n          <h3>{selectedRecipe.description}</h3>\n          {getMaterialStatus(selectedRecipe.id).map(material => (\n            <div key={material.itemId}>\n              {material.itemName}: {material.owned}/{material.required}\n            </div>\n          ))}\n          <button \n            onClick={handleCraft}\n            disabled={!canCraftRecipe(selectedRecipe.id)}\n          >\n            Craft\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n```\n\n---\n\n*Documentazione API aggiornata: Dicembre 2024*"