/**\n * craftingTypes.ts\n * \n * Utility functions per gestire diverse tipologie di crafting:\n * - Creazione di oggetti nuovi\n * - Miglioramento di oggetti esistenti\n * - Riparazione di oggetti danneggiati\n * - Smantellamento per recuperare materiali\n */\n\nimport type { Recipe, RecipeType, UpgradeConfig, RepairConfig } from '../types/crafting';\nimport type { InventoryItem, CharacterSheet } from '../interfaces/gameState';\nimport { debugLog } from './craftingUtils';\n\n// ===== TYPES =====\n\ninterface CraftingResult {\n  success: boolean;\n  message: string;\n  itemsAdded?: Array<{ itemId: string; quantity: number }>;\n  itemsRemoved?: Array<{ itemId: string; quantity: number }>;\n  xpGained?: number;\n}\n\ninterface ItemData {\n  id: string;\n  name: string;\n  type: string;\n  durability?: number;\n  maxDurability?: number;\n  damage?: number;\n  defense?: number;\n  value?: number;\n  weight?: number;\n  properties?: string[];\n}\n\n// ===== CREATION CRAFTING =====\n\n/**\n * Gestisce il crafting di creazione (oggetti completamente nuovi)\n */\nexport const handleCreationCrafting = (\n  recipe: Recipe,\n  inventory: InventoryItem[],\n  character: CharacterSheet,\n  itemDatabase: Record<string, ItemData>\n): CraftingResult => {\n  debugLog('handleCreationCrafting', `Processing creation recipe: ${recipe.id}`);\n  \n  // Verifica materiali\n  const materialsCheck = verifyMaterials(recipe.components, inventory);\n  if (!materialsCheck.success) {\n    return {\n      success: false,\n      message: materialsCheck.message\n    };\n  }\n  \n  // Verifica abilità\n  const skillCheck = verifySkillRequirement(recipe, character);\n  if (!skillCheck.success) {\n    return {\n      success: false,\n      message: skillCheck.message\n    };\n  }\n  \n  // Esegui crafting\n  const itemsRemoved = recipe.components.map(comp => ({\n    itemId: comp.itemId,\n    quantity: comp.quantity\n  }));\n  \n  const itemsAdded = [{\n    itemId: recipe.resultItemId,\n    quantity: recipe.resultQuantity\n  }];\n  \n  const resultItem = itemDatabase[recipe.resultItemId];\n  const itemName = resultItem?.name || 'Oggetto Sconosciuto';\n  \n  return {\n    success: true,\n    message: `Hai creato ${recipe.resultQuantity}x ${itemName}!`,\n    itemsAdded,\n    itemsRemoved,\n    xpGained: calculateCreationXP(recipe, character)\n  };\n};\n\n// ===== UPGRADE CRAFTING =====\n\n/**\n * Gestisce il crafting di miglioramento (potenziamento oggetti esistenti)\n */\nexport const handleUpgradeCrafting = (\n  recipe: Recipe,\n  inventory: InventoryItem[],\n  character: CharacterSheet,\n  itemDatabase: Record<string, ItemData>\n): CraftingResult => {\n  debugLog('handleUpgradeCrafting', `Processing upgrade recipe: ${recipe.id}`);\n  \n  if (!recipe.upgradeConfig) {\n    return {\n      success: false,\n      message: 'Configurazione di miglioramento mancante'\n    };\n  }\n  \n  const { upgradeConfig } = recipe;\n  \n  // Verifica che il giocatore abbia l'oggetto base\n  const baseItem = inventory.find(item => item.itemId === upgradeConfig.baseItemId);\n  if (!baseItem || baseItem.quantity < 1) {\n    const baseItemData = itemDatabase[upgradeConfig.baseItemId];\n    const baseItemName = baseItemData?.name || 'Oggetto Sconosciuto';\n    return {\n      success: false,\n      message: `Hai bisogno di ${baseItemName} per questo miglioramento`\n    };\n  }\n  \n  // Verifica materiali aggiuntivi\n  const materialsCheck = verifyMaterials(recipe.components, inventory);\n  if (!materialsCheck.success) {\n    return {\n      success: false,\n      message: materialsCheck.message\n    };\n  }\n  \n  // Verifica abilità\n  const skillCheck = verifySkillRequirement(recipe, character);\n  if (!skillCheck.success) {\n    return {\n      success: false,\n      message: skillCheck.message\n    };\n  }\n  \n  // Esegui miglioramento\n  const itemsRemoved = [\n    ...recipe.components.map(comp => ({\n      itemId: comp.itemId,\n      quantity: comp.quantity\n    }))\n  ];\n  \n  // Se l'oggetto base viene consumato, aggiungilo alla lista di rimozione\n  if (upgradeConfig.consumeBaseItem) {\n    itemsRemoved.push({\n      itemId: upgradeConfig.baseItemId,\n      quantity: 1\n    });\n  }\n  \n  const itemsAdded = [{\n    itemId: recipe.resultItemId,\n    quantity: recipe.resultQuantity\n  }];\n  \n  const resultItem = itemDatabase[recipe.resultItemId];\n  const itemName = resultItem?.name || 'Oggetto Migliorato';\n  \n  return {\n    success: true,\n    message: `Hai migliorato l'oggetto! Ottenuto: ${recipe.resultQuantity}x ${itemName}`,\n    itemsAdded,\n    itemsRemoved,\n    xpGained: calculateUpgradeXP(recipe, upgradeConfig, character)\n  };\n};\n\n// ===== REPAIR CRAFTING =====\n\n/**\n * Gestisce il crafting di riparazione (ripristino durabilità)\n */\nexport const handleRepairCrafting = (\n  recipe: Recipe,\n  inventory: InventoryItem[],\n  character: CharacterSheet,\n  itemDatabase: Record<string, ItemData>\n): CraftingResult => {\n  debugLog('handleRepairCrafting', `Processing repair recipe: ${recipe.id}`);\n  \n  if (!recipe.repairConfig) {\n    return {\n      success: false,\n      message: 'Configurazione di riparazione mancante'\n    };\n  }\n  \n  const { repairConfig } = recipe;\n  \n  // Trova oggetti riparabili nell'inventario\n  const repairableItems = inventory.filter(item => {\n    const itemData = itemDatabase[item.itemId];\n    return itemData && repairConfig.repairableTypes.includes(itemData.type);\n  });\n  \n  if (repairableItems.length === 0) {\n    return {\n      success: false,\n      message: 'Non hai oggetti riparabili di questo tipo'\n    };\n  }\n  \n  // Verifica materiali\n  const materialsCheck = verifyMaterials(recipe.components, inventory);\n  if (!materialsCheck.success) {\n    return {\n      success: false,\n      message: materialsCheck.message\n    };\n  }\n  \n  // Verifica abilità\n  const skillCheck = verifySkillRequirement(recipe, character);\n  if (!skillCheck.success) {\n    return {\n      success: false,\n      message: skillCheck.message\n    };\n  }\n  \n  // Controlla se la riparazione può fallire\n  if (repairConfig.canFail && repairConfig.successChance) {\n    const roll = Math.random() * 100;\n    if (roll > repairConfig.successChance) {\n      // Riparazione fallita - consuma comunque i materiali\n      const itemsRemoved = recipe.components.map(comp => ({\n        itemId: comp.itemId,\n        quantity: comp.quantity\n      }));\n      \n      return {\n        success: false,\n        message: 'La riparazione è fallita! I materiali sono stati consumati.',\n        itemsRemoved,\n        xpGained: Math.floor(calculateRepairXP(recipe, character) * 0.3) // XP ridotto per fallimento\n      };\n    }\n  }\n  \n  // Riparazione riuscita\n  const itemsRemoved = recipe.components.map(comp => ({\n    itemId: comp.itemId,\n    quantity: comp.quantity\n  }));\n  \n  // TODO: Implementare logica di ripristino durabilità\n  // Per ora restituiamo un messaggio generico\n  \n  return {\n    success: true,\n    message: `Riparazione completata! Durabilità ripristinata del ${repairConfig.durabilityRestored}%`,\n    itemsRemoved,\n    xpGained: calculateRepairXP(recipe, character)\n  };\n};\n\n// ===== DISMANTLE CRAFTING =====\n\n/**\n * Gestisce il crafting di smantellamento (recupero materiali)\n */\nexport const handleDismantleCrafting = (\n  recipe: Recipe,\n  inventory: InventoryItem[],\n  character: CharacterSheet,\n  itemDatabase: Record<string, ItemData>\n): CraftingResult => {\n  debugLog('handleDismantleCrafting', `Processing dismantle recipe: ${recipe.id}`);\n  \n  // Per lo smantellamento, i \"componenti\" sono gli oggetti da smantellare\n  const materialsCheck = verifyMaterials(recipe.components, inventory);\n  if (!materialsCheck.success) {\n    return {\n      success: false,\n      message: materialsCheck.message\n    };\n  }\n  \n  // Verifica abilità\n  const skillCheck = verifySkillRequirement(recipe, character);\n  if (!skillCheck.success) {\n    return {\n      success: false,\n      message: skillCheck.message\n    };\n  }\n  \n  // Esegui smantellamento\n  const itemsRemoved = recipe.components.map(comp => ({\n    itemId: comp.itemId,\n    quantity: comp.quantity\n  }));\n  \n  const itemsAdded = [{\n    itemId: recipe.resultItemId,\n    quantity: recipe.resultQuantity\n  }];\n  \n  const resultItem = itemDatabase[recipe.resultItemId];\n  const itemName = resultItem?.name || 'Materiali';\n  \n  return {\n    success: true,\n    message: `Smantellamento completato! Ottenuto: ${recipe.resultQuantity}x ${itemName}`,\n    itemsAdded,\n    itemsRemoved,\n    xpGained: calculateDismantleXP(recipe, character)\n  };\n};\n\n// ===== ENHANCEMENT CRAFTING =====\n\n/**\n * Gestisce il crafting di potenziamento (aggiunta proprietà speciali)\n */\nexport const handleEnhancementCrafting = (\n  recipe: Recipe,\n  inventory: InventoryItem[],\n  character: CharacterSheet,\n  itemDatabase: Record<string, ItemData>\n): CraftingResult => {\n  debugLog('handleEnhancementCrafting', `Processing enhancement recipe: ${recipe.id}`);\n  \n  // Simile all'upgrade ma per proprietà speciali\n  return handleUpgradeCrafting(recipe, inventory, character, itemDatabase);\n};\n\n// ===== MAIN DISPATCHER =====\n\n/**\n * Dispatcher principale per gestire tutti i tipi di crafting\n */\nexport const processCraftingByType = (\n  recipe: Recipe,\n  inventory: InventoryItem[],\n  character: CharacterSheet,\n  itemDatabase: Record<string, ItemData>\n): CraftingResult => {\n  const recipeType = recipe.type || 'creation';\n  \n  debugLog('processCraftingByType', `Processing recipe ${recipe.id} of type ${recipeType}`);\n  \n  switch (recipeType) {\n    case 'creation':\n      return handleCreationCrafting(recipe, inventory, character, itemDatabase);\n      \n    case 'upgrade':\n      return handleUpgradeCrafting(recipe, inventory, character, itemDatabase);\n      \n    case 'repair':\n      return handleRepairCrafting(recipe, inventory, character, itemDatabase);\n      \n    case 'dismantle':\n      return handleDismantleCrafting(recipe, inventory, character, itemDatabase);\n      \n    case 'enhancement':\n      return handleEnhancementCrafting(recipe, inventory, character, itemDatabase);\n      \n    default:\n      return {\n        success: false,\n        message: `Tipo di ricetta non supportato: ${recipeType}`\n      };\n  }\n};\n\n// ===== UTILITY FUNCTIONS =====\n\n/**\n * Verifica se i materiali richiesti sono disponibili\n */\nconst verifyMaterials = (\n  components: Array<{ itemId: string; quantity: number }>,\n  inventory: InventoryItem[]\n): { success: boolean; message: string } => {\n  for (const component of components) {\n    const inventoryItem = inventory.find(item => item.itemId === component.itemId);\n    if (!inventoryItem || inventoryItem.quantity < component.quantity) {\n      return {\n        success: false,\n        message: `Materiali insufficienti: ${component.itemId} (${inventoryItem?.quantity || 0}/${component.quantity})`\n      };\n    }\n  }\n  \n  return { success: true, message: '' };\n};\n\n/**\n * Verifica se i requisiti di abilità sono soddisfatti\n */\nconst verifySkillRequirement = (\n  recipe: Recipe,\n  character: CharacterSheet\n): { success: boolean; message: string } => {\n  if (!recipe.skillRequirement) {\n    return { success: true, message: '' };\n  }\n  \n  const { skill, level } = recipe.skillRequirement;\n  \n  // Mappa le abilità alle statistiche del personaggio\n  const skillMapping: Record<string, keyof typeof character.stats> = {\n    'crafting': 'adattamento',\n    'smithing': 'potenza',\n    'alchemy': 'percezione',\n    'cooking': 'adattamento',\n    'engineering': 'percezione',\n    'tailoring': 'percezione'\n  };\n  \n  const statName = skillMapping[skill.toLowerCase()];\n  if (!statName || !character.stats || character.stats[statName] < level) {\n    return {\n      success: false,\n      message: `Abilità ${skill} insufficiente (richiesto livello ${level})`\n    };\n  }\n  \n  return { success: true, message: '' };\n};\n\n// ===== XP CALCULATION =====\n\n/**\n * Calcola XP per crafting di creazione\n */\nconst calculateCreationXP = (recipe: Recipe, character: CharacterSheet): number => {\n  const baseXP = 15;\n  const complexityMultiplier = 1 + (recipe.components.length * 0.3);\n  const quantityMultiplier = 1 + (recipe.resultQuantity - 1) * 0.2;\n  \n  return Math.floor(baseXP * complexityMultiplier * quantityMultiplier);\n};\n\n/**\n * Calcola XP per crafting di miglioramento\n */\nconst calculateUpgradeXP = (\n  recipe: Recipe, \n  upgradeConfig: UpgradeConfig, \n  character: CharacterSheet\n): number => {\n  const baseXP = 25; // Più XP per i miglioramenti\n  const levelMultiplier = 1 + (upgradeConfig.upgradeLevel * 0.5);\n  const complexityMultiplier = 1 + (recipe.components.length * 0.2);\n  \n  return Math.floor(baseXP * levelMultiplier * complexityMultiplier);\n};\n\n/**\n * Calcola XP per crafting di riparazione\n */\nconst calculateRepairXP = (recipe: Recipe, character: CharacterSheet): number => {\n  const baseXP = 10; // Meno XP per le riparazioni\n  const complexityMultiplier = 1 + (recipe.components.length * 0.2);\n  \n  return Math.floor(baseXP * complexityMultiplier);\n};\n\n/**\n * Calcola XP per crafting di smantellamento\n */\nconst calculateDismantleXP = (recipe: Recipe, character: CharacterSheet): number => {\n  const baseXP = 8; // Poco XP per lo smantellamento\n  const quantityMultiplier = 1 + (recipe.resultQuantity - 1) * 0.1;\n  \n  return Math.floor(baseXP * quantityMultiplier);\n};\n\n// ===== RECIPE VALIDATION =====\n\n/**\n * Valida una ricetta per un tipo specifico\n */\nexport const validateRecipeForType = (\n  recipe: Recipe,\n  itemDatabase: Record<string, ItemData>\n): { valid: boolean; errors: string[] } => {\n  const errors: string[] = [];\n  const recipeType = recipe.type || 'creation';\n  \n  switch (recipeType) {\n    case 'upgrade':\n      if (!recipe.upgradeConfig) {\n        errors.push('Ricetta di miglioramento senza configurazione upgrade');\n      } else {\n        // Verifica che l'oggetto base esista\n        if (!itemDatabase[recipe.upgradeConfig.baseItemId]) {\n          errors.push(`Oggetto base non trovato: ${recipe.upgradeConfig.baseItemId}`);\n        }\n      }\n      break;\n      \n    case 'repair':\n      if (!recipe.repairConfig) {\n        errors.push('Ricetta di riparazione senza configurazione repair');\n      }\n      break;\n      \n    case 'dismantle':\n      // Per lo smantellamento, verifica che gli oggetti da smantellare esistano\n      recipe.components.forEach(component => {\n        if (!itemDatabase[component.itemId]) {\n          errors.push(`Oggetto da smantellare non trovato: ${component.itemId}`);\n        }\n      });\n      break;\n  }\n  \n  // Verifica che l'oggetto risultante esista\n  if (!itemDatabase[recipe.resultItemId]) {\n    errors.push(`Oggetto risultante non trovato: ${recipe.resultItemId}`);\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors\n  };\n};"